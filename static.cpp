#include <iostream>
#include <set>


void f() {
	/// Статическая переменная в функции сохраняет значение между вызовами.
	/// Начальная инициализация происходит при запуске программы ЕЩВЩ
	static int i = 0;
	std::cout << "f(): i == " << i++ << std::endl;
}

class A {
public:
	/// Статическая переменная в классе -- переменная, связанная не с конкретным
	/// объектом, а с классом вообще.
	/// Целочисленные static const переменные можно определить прямо внутри класса:
	static const int I = 1;
	static double D;
	static const std::set<double> SET;
	static constexpr double DC = 0.7;
	
	/// static-функция, аналогично, связана только с типом и, соответственно,
	/// имеет доступ только к static полям класса
	static void foo() {
		D += I;
		/// Так нельзя:
		// nonStaticVariable = 5;
	}
	int nonStaticVariable = 0;
};

/// Не целочисленные или не константные static поля определяются вне класса в ".cpp"-файле:
const std::set<double> A::SET = { 1.5, 7.7 };
/// Порядок определения совпадает с порядком инициализации
double A::D = *(A::SET.begin());

/// Инициализация всех объектов в единице компиляции происходит до выполнения
/// каких-либо функций или использования объектов из единицы компиляции
int main() {
	f(); f(); f();
	
	/// static const integer известен в момент компиляции
	int array[A::I];
	
	/// static-переменная относится к классу, а не к объекту.
	/// Кстати, об этом стоит помнить при многопоточности в том числе
	A a1, a2;
	std::cout << a1.D << " " << a2.D << std::endl;
	a1.D = 5.5;
	std::cout << a1.D << " " << a2.D << std::endl;
	
	std::set<int> tmp;
	/// Ошибка компиляции "undefined reference to `A::I'"
	// tmp.insert(A::I);
	/// Нет ошибки =)
	tmp.insert((int)(A::I));
	
	/// Аргумент -- ссылка: insert(const value_type& __x)
	/// То есть где-то в памяти должен быть объект, на который ссылаются
	/// A::I нет в памяти в момент исполнения, при компиляции уже
	/// было везде просто подставлено его значение
	
	return 0;
}

